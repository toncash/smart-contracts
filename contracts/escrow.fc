#include "imports/stdlib.fc";

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {  ;; well known function signature
  if (in_msg_body.slice_empty?()) {         ;; check if incoming message is empty (with no body)
    return ();                            ;; return successfully and accept an empty message
  }

;;   int op = in_msg_body~load_uint(512);       ;; parse the operation type encoded in the beginning of msg body
  var firstSin = load_first_signature(in_msg_body);
;;   var ds = get_data().begin_parse();
;;   var (stored_seqno, stored_subwallet, public_key, plugins) = (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256), ds~load_dict());
;;   ds.end_parse();


  var secondSin = load_second_signature(in_msg_body);

  if (op == firstSin) {
    ;; здесь я меняю value кошелька
    throw_unless(35, check_signature(slice_hash(in_msg), firstSin, public_key));
  }
  if (op == secondSin) {

  }
}

(int) load_first_signature(slice in_msg_body) inline {
  var ds = in_msg_body.begin_parse();
  return (ds~load_uint(512));
}

(int) load_second_signature(slice in_msg_body) inline {
  var ds = in_msg_body.begin_parse();
  return (ds~skip_bits(512).load_uint(512));
}

() save_data(int counter) impure inline {  ;; write function declaration - takes an int as arg
  set_data(begin_cell()                    ;; store the storage cell and create it with a builder
    .store_uint(counter, 512)               ;; write a 64 bit unsigned int to the builder
    .end_cell());                          ;; convert the builder to a cell
}


